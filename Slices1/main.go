package main

import "fmt"

func Names(s []string) {
	s[2] = "Franklin"
}

func main() {
	arr := [7]int{0, 1, 2, 3, 4, 5, 6} // так инициализируется массив !!!равно перед списком значений не нужно!!!

	var slice []int = arr[:7] // так создается слайс

	fmt.Println(slice[:]) // так выводится слайс

	str := [3]string{"Michael", "Trevor", "CJ"} // снова инициализация массива с именами

	sli := str[:] // слайс можно объявлять даже без указания типа данных массива и границ слайса (!!!двоеточие обязательно!!! будет взят массив полностью)

	Names(sli) // функция получает на вход слайс

	fmt.Println(str) // но изменения в слайсе влияют на исходный массив, потому что слайс содержит указатели на "лежащий под ним" массив

	logic := []bool{true, true, false, false} // создать слайс можно и без предварительного создания массива, он создастся неявно
	logic[3] = true
	fmt.Println(logic)

	cars := []struct { //создаю слайс структуру по примеру из go.dev
		model      string
		maxSpeed   int
		isElectric bool
	}{
		{"Mustang", 250, false},
		{"Cybertruck", 200, true},
		{"Viper", 280, false},
		{"Civic", 180, false},
		{"Leaf", 140, true},
	}

	fmt.Println(cars)

	fmt.Println("Car in slot 2 is", cars[1].model) // вывожу только одно поле из слайса с машинами, по сути таким образом можно сделать структуру в структуре с помощью слайсов и удобно обращаться к данным, надо выяснить удобно ли это, или есть способы сделать это лучшим образом
	i := 0

	for i < len(cars) { // просто вывод через цикл
		fmt.Println("#", i+1, "car in garage is", cars[i].model)
		fmt.Println(cars[i].model, "max Speed is", cars[i].maxSpeed)
		if cars[i].isElectric {
			fmt.Println(cars[i].model, "is an Elecric car!")
		} else {
			fmt.Println(cars[i].model, "is not an Elecric car!\n")
		}

		i++
	}

	c := cap(cars)
	l := len(cars)
	fmt.Println("cap of slice cars -", c, "length of slice cars - ", l) // вместимость (ёмкость) и длина слайса cars

	//слайс через make
	newslice := make([]int, 5, 6) // len(newslice) = 5, cap(newslice) = 10

	// наполняю слайс значениями через цикл
	i = 0
	for i < len(newslice) {
		newslice[i] = i
		i++
	}

	// удаляю первый элемент переназначая слайс
	tempSlice := newslice[1:]
	fmt.Println(tempSlice)
	fmt.Println(len(tempSlice))
	fmt.Println(cap(tempSlice))

	// вывожу новый слайс и смотрю его длину и ёмкость
	fmt.Println(newslice)
	fmt.Println(len(newslice))
	fmt.Println(cap(newslice), "\n")

	printSlice("newslice:", newslice) // newslice: len=5 cap=6 elements: [0 1 2 3 4]

	addOneElem(&newslice)            // передаю в функцию ссылку на слайс, чтобы изменять исходные данные
	printSlice("newslice", newslice) // newslice len=6 cap=6 elements: [0 1 2 3 4 52]

	addOneElem(&newslice)            // и ещё раз для того чтобы выйти за пределы текущей ёмкости
	printSlice("newslice", newslice) // newslice len=7 cap=12 elements: [0 1 2 3 4 52 52] (ёмкость увеличилась вдвое при добавлении массива)
}

// создал функцию для быстрого вывода слайса
func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d elements: %v\n",
		s, len(x), cap(x), x)
}

// функция работает с указателем на слайс, чтобы изменения касались не копии, а оригинала
func addOneElem(x *[]int) {
	*x = append(*x, 52)
}

/** В Go массив и слайс - это принципиально разные структуры данных. Массив - это фиксированная по размеру область памяти, чей тип включает его размер (например, [3]int). При передаче массива в функцию происходит полное копирование данных, что может быть затратно для больших массивов.

Слайс же представляет собой 'окно' в массив и состоит из трех компонентов: указателя на базовый массив, длины и ёмкости. Слайсы передаются по ссылке (фактически передается указатель), что делает их более эффективными для передачи в функции. Однако важно понимать, что операции вроде append могут приводить к переаллокации памяти, если ёмкости недостаточно, что создает новый массив и копирует в него элементы.

При работе со слайсами нужно учитывать несколько тонкостей. Во-первых, изменение элементов слайса в функции влияет на оригинал, так как они разделяют один базовый массив. Во-вторых, 'усечение' слайса может привести к утечкам памяти, так как сборщик мусора видит только ссылку на весь базовый массив. В-третьих, слайсы нельзя сравнивать напрямую, в отличие от массивов.

Для оптимальной работы со слайсами важно правильно задавать начальную ёмкость через make, когда она известна заранее, чтобы избежать частых переаллокаций. Также стоит быть осторожным с передачей слайсов в горутины, так как они разделяют общее состояние базового массива. **/
